#### 介绍

- 以太坊gas用来控制交易对资源的使用
- gas是到交易结束后才会扣除
- gas的平均价格是有矿工决定的
- 转账1ETH，实际扣除>=1ETH+gas费

#### gas费预估和计算

- 可以通过gasEstimate预估某个调用所需的gas开销
- 可以通过getGasPrice来gas price,
- gasLimit是固定值21000乘以浮动的gasPrice就是gas

#### gas耗尽

- 在执行过程中gas耗尽会触发如下一系列事件
    - 抛出"out of gas"异常
    - 状态会被恢复到执行之前
    - 所有在这次执行过程中的gas开销都会被作为交易费用，以太坊不会因为交易中止（或某种原因导致交易失败）而退还gas或以太币

#### 交易失败是否扣除gas

- 交易是原子化的，是个原子操作，要么全部成功，要么全部失败，但是失败的时候，gas仍会扣掉

## 节省gas费

1. 注意数据类型  
   考虑到以太坊EVM的特性，最好使用256bit的变量，如uint256和bytes32。每个存储槽有256bit。因此如果值存储一个uint8变量，EVM必须因为256bit对齐的原因而补0，这需要消耗燃料。另外EVM计算必须基于uint256,如果使用非uint256变量必须先将非uint256类型转换成uint256类型，再进行计算。
2. 以字节码的形式存储值  
   相对经济的存储和读取信息的方法是直接将信息包含在智能合约中，作为字节码。  
   缺点是：一旦部署其值将不能改变  
   优点是：花费在引导/存储数据上的gas将大大降低
   字节码存储有两种可能的实现方法：  
   1 变量声明的时候使用constant变量  
   2 固定编码/Hardcode变量

   ``` solidity
      uint256 public v1;
      uint256 public constant v2;
   ```

   以上代码：变量v1在合约的存储领域，变量v2则在合约的字节码中。读取v1需要通过sload操作来实现，将要消耗200燃料费
3. 利用SOLC编译器压缩变量  
   把多个变量放入同一个存储槽，要比补零填充更节省，可以利用SOLC编译器进行压缩优化  
   类似于结构体内存对齐
4. 使用汇编代码压缩变量  
   可以把多个变量压缩进一个256bit存储槽  
   assembly{}
5. 合并函数参数
6. 无状态的合约
7. 在IPFS上存储数据  
   默克尔树：小到中型数据，数据可以在合约里直接使用，修改数据比较复杂  
   Stateless合约：小型到中型数据，数据不能在合约里直接使用，数据可修改  
   IPFS：大型数据，在合约里使用数据很繁琐，修改数据比较复杂
8. 位压缩
9. 批处理
10. Storage结构类型读写分离
11. uint256和直接内存存储  
    SOLC的计算单位是uint256。因此其他类型（如uint8）在进行计算时要先进行类型转换，这会需要额外的燃料成本。  
    另外直接访问内存比直接访问Storage会更省gas，而且比基于结构体的指针访问更省gas。 可以看下面小技巧
   ``` solidity
       //1 uint8 可以直接用uint256类型，如果在结构体里，优先考虑是否可以和其他变量内存对齐
       // 2
       uint256 val = storageData;
       uint256 memoryData = storageData;
       // 此处省略memoryData参与的各种逻辑，最后将memoryData再赋值给val（storage data）
       uint256 val = memoryData;
   ```
12. 汇编代码优化  
    在使用SOLC编译时，一定要打开Gas成本编译开关 SOLC 'optimize--runs',以便找到最优的可以在EVM上运行的代码。

#### 总结

- estimateGas（估算燃料费）在该节点的EVM上执行一个消息调用或者交易，但是并不广播打包上链（这意味着没有必要在网络里所有节点同步，所以不用付钱），然后返回所需的gas数量。
- 可以参